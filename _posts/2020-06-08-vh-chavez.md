---
name: sample-poster
title: PDFT | An accessible density embedding code. 
author: "Victor H. Chavez"
mentor-names: "Taylor Barnes"
full-author-list:
    - name: "Victor H. Chavez"
      affiliation: 1
    - name: "Yuming Shi"
      affiliation: 1
    - name: "Yan Oueis"
      affiliation: 1
    - name: "Adam Wasserman"
      affiliation: 1
affiliations:
    - name: "Department of Chemistry, Purdue University"
      address: "West Lafayette, IN"
      index: 1
toc: true
toc_sticky: true
toc_label: "Poster Contents"
layout: poster
---

## Introduction

Density embedding methods avoid the exponential scaling that hinders users from using accurate quantum chemistry in large and complex systems. Partition Density Functional Theory (PDFT), relies on non-interacting fragments, so that the energy of the entire system, and any other electronic properties, is given by functionals of the set of the less computationally demanding fragment densities.

$$ E[n( \mathbf{r} )] \rightarrow E[{n_1(\mathbf{r}), n_2(\mathbf{r}), n_3(\mathbf{r}),...}]$$ Subjected to the constraint that $$ \sum_i n_i(\mathbf{r}) = n_m(\mathbf{r}) $$ 

The caveat is that an extra component is missing: The partition potential, that accounts for inter-fragment interaction. This extra component modifies the external potential of each fragment just slightly so that the sum of all the fragment densities matches the molecular density. Thus, in practice, we require a partition potential, wether being "exact" or approximated. Our code, PDFT, is set to do just that. 

## PDFT in Code:

The advent of interpreted languages such as Python and the widely use open source in the computational molecular sciences, has lowered the effort required by non-developers to easily write and share code. Furthermore, efforts like the Molecular Sciences Software Institute (MolSSI), have set the standard for code in our community to have the most utmost quality, striving for code that is readable, reliable and reusable.

PDFT has had those values since its conceptions and it keeps striding for sharable and reusable code. PDFT is written on Python using PSIAPI. At its core PDFT performs self-consistent field calculations ona molecule defined just like Psi4Numpy. The SCF solves the Hohenberg-Kohn equation for the energy by diagonlizing the DFT Fock Matrix:

$$
F^{DFT}_{\mu \nu} = H_{\mu \nu} + 2J[D]_{\mu \nu} - \zeta K[D]_{\mu \nu} + V^{xc}_{\mu \nu}
$$

Making a DFT calculation in PDFT is extremely easy, and users of Psi4Numpy will find it extremely familiar. Given an exchange-correlation approximation accesible in Libxc, one can calculate the energy of a hydrogen atom using the Local Density Approximation (LDA) in the Universal Gaussian Basis set (UGBS) as:

{% highlight python %}
import psi4
import pdft

psi4.set_options({“reference”:”uhf”})

#Geometry Definition
H_geo = psi4.geometry(“””
0 2
H””)

H = pdft.UMolecule(H_geometry, “ugbs”, “svwn”)
#Run scf cycle
h.scf()
{% endhighlight %}

Notice that PDFT uses the standard molecule definition of Psi4, but it is then used to define an instance of the class ```UMolecule```, which is then to perform a scf calculation.

PDFT contains two main classes, ```RMolecule``` and ```uMolecule```. Both are inherited from a parent class Molecule, that allows for modifications to be directly reflected on each child, making additions, troubleshooting and debugging a breeze.

The components of the Fock-Matrix are expressed in the atomic orbital basis which makes it not straight forward to visualize on the grid. PDFT automatically sets each component on the grid automatically as attributes so that any component can be quickly visualized on the grid. One can access this by running the scf as:

{% highlight python %}
h.scf(get_ingredients=True, get_orbitals=True)
{% endhighlight %}

The first option ```get_ingredients``` stores components relevant to the development of Density Functional Approximations (DFA), such as the density and its derivatives, kinetic energy density and components of the Kohn-Sham potential, whereas the latter option ```get_orbitals``` stores each of the molecular orbitals both on the atomic orbital basis and on the grid. 

One of the goals of the programs is to build very common DFT informaitons in a very simple way. In Figure 1. and Figure 2. we present some common plots in the development of density functionals.This makes visualization effortless. Take for example the Self-Interaction error. An exchange-correlation potential from a DFA won't be able to fully cancel out the Hartree potential. Generating a spurious behavior where an electron will interact with itself. Consider the calculation we performed using LDA, after running the scf cycle we can visualize the potentials on the fly, that is:

{% highlight python %}
vha = h.potential["vha"]
vxc = h.potential["vxc"]

h.axis_plot_r([vha, vxc], labels=["V_Hartree", "v_xc"])
{% endhighlight %}

Which will result in the following plot:  

![NSF Logo]({{ site.url }}{{ site.baseurl }}/assets/images/vh_chavez/SIE.png)  
***Figure 1**: Self-interaction error of the LDA for the Hydrogen atoms.*

Moreover, other components relevant for other DFA, such as GGA can easily be extracted on the grid. Consider the dimensionless ingredients of functional derivatives of HF/UGBS of the Kr atom. 

{% highlight python %}
#Basic calculation:
Kr_geometry = psi4.geometry("""
0 1
Kr 0.0 0.0 0.0
units bohr
symmetry c1
""")

Kr = pdft.UMolecule(Kr_geometry, "ugbs", "hf")
Kr.scf(get_matrices=True, get_ingredients=True, get_orbitals=True)

r = []
for i_block in range(Kr.nblocks):
    r.append((Kr.grid["x"][i_block]**2 + Kr.grid["y"][i_block]**2 + Kr.grid["z"][i_block]**2)**(1/2))
r = np.array(r)
    
density = Kr.ingredients["density"]["da"] + Kr.ingredients["density"]["db"]
    
#Density
n =(4 * np.pi * r**2) * density

#Gradient
s =  (Kr.ingredients["gradient"]["da_x"] + Kr.ingredients["gradient"]["db_x"])**2
s += (Kr.ingredients["gradient"]["da_y"] + Kr.ingredients["gradient"]["db_y"])**2
s += (Kr.ingredients["gradient"]["da_z"] + Kr.ingredients["gradient"]["db_z"])**2
for i_block in range(Kr.nblocks):
    s[i_block] = np.sqrt(s[i_block])
s /= density**(4/3)

#Laplacian
q = Kr.ingredients["laplacian"]["la_x"] + Kr.ingredients["laplacian"]["lb_x"]
q += Kr.ingredients["laplacian"]["la_z"] + Kr.ingredients["laplacian"]["lb_y"]
q += Kr.ingredients["laplacian"]["la_y"] + Kr.ingredients["laplacian"]["lb_z"]
q /= density**(5/3)
{% endhighlight %}

And each of the components can be individually plotted to produce:

![NSF Logo]({{ site.url }}{{ site.baseurl }}/assets/images/vh_chavez/ingredients.png)  
***Figure 2**: Dimensionless ingredients of GGA's for a Kr atom.*


## Advanced methods in PDFT

Having an scf cycle completely written in Python allows it to be quickly modified to suit a developers needs. For example, in embedding methods, we are required to add an external potential that modifies each of the fragments so that they can match the full molecular density. Assuming one has a partition potential $v_p(r)$ expressed in the atomic orbital basis, one can simply run an scf calculation like:

{% highlight python %}
h.scf(vp=potential_mn)
{% endhighlight %}

This feature is extremely useful when using inversion methods. Where a potential such as the embedding potential can be obtained "exactly" (for a given density functional approximation and a basis set), by using an algorithm that will ensure that the target density is reached. Such an algorithm is exemplified in the next figure. 

![NSF Logo]({{ site.url }}{{ site.baseurl }}/assets/images/vh_chavez/vp_update.png)  
***Figure 3**: Model algorithm for the generation of an embedding potential given a set of fragments and a target density.*

Such an algorithm is implemented in the class Inversion within PDFT. Where the most relevant component is the generation of $$\delta v_p(r)$$ in step 4. Finding the appropriate $$\delta v_p(r)$$ in step 4 is the most relevant component in an inversion procedure. They can be technically as simple as dependant on the density difference, and as complicated as requiring information about the occupied and unoccupied orbitals. These inversion procedures are commonly known to be very finicky when it comes to initial guess and choice of basis set. Although basic algorithms such as density difference and ZMP are implemented, we are working on making other common methods such as Wu-Yang, and more recently Ou-Carter methods to be not only available, but also to be reliable and to require minimum input from the user. 
Given the nature of the attributes of each Molecule such as the ao, and density ingredients, we are confident that our code will provide a quick and easy way of trying and benchmarking new inversion methods.

## Future of PDFT

### To be (approximated) or not to be: That is the question.
Although inversions the one procedure required for finding the exact embedding potential, in practice one desires to have an approximation to the non-additive kinetic energy functional (NAKE). PDFT will have an abstract class for the NAKE functional, this will result in each approximation having a consistent set of attributes that will provide a blueprint for new proposed functionals from the broader research community. 



## References
1. Jonathan Nafziger and Adam Wasserman. Density-based partitioning methods for ground-state molecular calculations. The Journal of Physical Chemistry A, 118(36): 7623–7639, 2014.  
2. Peter Elliott, Kieron Burke, Morrel H. Cohen, and Adam Wasserman. Partition densityfunctional theory. Physical Review A, 82(2):024501, 2010.  
3. Martin A. Mosquera and Adam Wasserman. Partition density functional theory and its extension to the spin-polarized case. Molecular Physics, 111(4):505–515, 2013.  
4.  Victor H. Chavez and Adam Wasserman. Towards a density functional theory of molecular fragments. what is the shape of atoms in molecules? Revista de la Academia Colombiana de Ciencias Exactas, Fisicas y Naturales, 44(170):269–279, 2020
5. Smith, D. G., Burns, L. A., Simmonett, A. C., Parrish, R. M., Schieber, M. C., Galvelis, R., ... & James, A. M. (2020). PSI4 1.4: Open-source software for high-throughput quantum chemistry. The Journal of Chemical Physics, 152(18), 184108.  
6. Smith, D. G., Burns, L. A., Sirianni, D. A., Nascimento, D. R., Kumar, A., James, A. M., ... & Berquist, E. J. (2018). Psi4NumPy: An interactive quantum chemistry programming environment for reference implementations and rapid development. Journal of chemical theory and computation, 14(7), 3504-3511.
7. Gaiduk, A. P., Mizzi, D., & Staroverov, V. N. (2012). Self-interaction correction scheme for approximate Kohn-Sham potentials. Physical Review A, 86(5), 052518.
8. Gaiduk, A. P., & Staroverov, V. N. (2011). Construction of integrable model Kohn-Sham potentials by analysis of the structure of functional derivatives. Physical Review A, 83(1), 012509.


### Acknowledgements

Victor H. Chavez was supported by a fellowship from The Molecular Sciences Software Institute under NSF grant OAC-1547580

![NSF Logo]({{ site.url }}{{ site.baseurl }}/assets/images/sample-poster/nsf.png) 
